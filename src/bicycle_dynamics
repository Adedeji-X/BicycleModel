#!/usr/bin/python
from __future__ import division
from math import *
import numpy as np
import scipy as sp
import sys
import matplotlib.pyplot as plt

from matplotlib import animation

from modules.bicycleTemplate import *
from modules.auxiliaryLib import *

def dampingAngle(x):
    """ Computes the correction angle to steer the front wheel angle towards
    the target.
    Returns: correction angle (heuristically determined)
    """
    return atan(x) / 6.

def angleFromFrameToDestination(frameVector, frameToTargetVector):
    """ Calculates the angle between the frame vector of the bicycle and the target
    Returns: angle eta
    """
    eta = acos(np.dot(frameVector, frameToTargetVector) / (np.linalg.norm(frameVector) * np.linalg.norm(frameToTargetVector)))
    determinant = frameVector[0] * frameToTargetVector[1] - frameVector[1] * frameToTargetVector[0]
    # Adjust the sign of eta accordingly
    if determinant < 0.:
        eta = -eta
    return eta
    
def correctSteeringAngle(bike, bikes):
    """ Checks whether the front wheel is aligned with the target
    and steers if necessary
    Returns: none
    """
    # Compute some preliminary vectors
    frameVector = bike.frontWheelPosition - bike.position
    # Normalised vector from the current bicycle centre-of-mass position to its target
    normalisedVectorFromFrameToTarget = normalisedDesiredDirection(bike.target, bike.position)
    # External normalised vectors from external bicycle centre-of-mass positions to current bicycle centre-of-mass position
    # weighted with a distance dependent factor (heuristically determined) 
    externalFramesToFrameWeightedVectors = np.array([5.*exp(-np.linalg.norm(bike.position-externalBike.position)/4.) * normalisedDesiredDirection(bike.position, externalBike.position) for externalBike in bikes])
    # Resulting vector
    eFT = normalisedVectorFromFrameToTarget + sum(externalFramesToFrameWeightedVectors)
#     eFT = normalisedVectorFromFrameToTarget + externalFramesToFrameWeightedVectors
    # Associated angle
    eta = angleFromFrameToDestination(frameVector, eFT)
    # Correct the steering angle
    delta = bike.frontWheelAngle + dampingAngle(eta-bike.frontWheelAngle)
    if -np.pi/4. < delta < np.pi/4.:
            bike.updateFrontWheelAngle(delta)   

def differentialEquationInVx(Cf, Cr, lf, lr, vx, vy, Iz, m, delta, psiDot, Fx):
    """ Defines the differential equation in vx according to the Lateral Bicycle Model
    Returns: vxDot
    """
    alphaf = atan2(vy + lf * psiDot, vx)
    alphar = atan2(vy - lr * psiDot, vx)
    term1 = Cf * (1. - 1./cos(alphaf)) * cos(delta)
    term2 = - Cf * (delta - alphaf) * sin(delta)
    term3 = Cr * (1. - 1./cos(alphar))
    term4 = vy * psiDot + Fx
    return (term1 + term2 + term3 + term4) / m

def differentialEquationInVy(Cf, Cr, lf, lr, vx, vy, Iz, m, delta, psiDot, Fy):
    """ Defines the differential equation in vy according to the Lateral Bicycle Model
    Returns: vyDot
    """
    alphaf = atan2(vy + lf * psiDot, vx)
    alphar = atan2(vy - lr * psiDot, vx)
    term1 = Cf * (1. - 1./cos(alphaf)) * sin(delta)
    term2 = Cf * (delta - alphaf) * cos(delta)
    term3 = -Cr * alphar
    term4 = -vx * psiDot + Fy
    return (term1 + term2 + term3 + term4) / m

def differentialEquationInInertialMomentum(Cf, Cr, lf, lr, vx, vy, Iz, delta, psiDot):
    """ Defines the differential equation in psiDot according to the Lateral Bicycle Model
    Returns: psiDotDot
    """
    alphaf = atan2(vy + lf * psiDot, vx)
    alphar = atan2(vy - lr * psiDot, vx)
    term1 = Cf * (1. - 1./cos(alphaf)) * sin(delta) + Cf * (delta - alphaf) * cos(delta)
    term1 = term1 * lf
    term2 = Cr * alphar * lr 
    return term1 + term2

def systemOfODEsForDynamics(bike):
    """ Defines the system of ODEs for a single bicycle according to the inner frame 
    and system of coordinates described in the Lateral Bicycle model
    Returns: derivatives of the lateral coordinate y and orientation angle
    """ 
    
    forceToDestination = attractiveForceToDestination(bike.velocity, bike.desiredVelocity, bike.position, bike.target)
    F = np.linalg.norm(forceToDestination) * atan(np.linalg.norm(bike.target-bike.position))
#     print atan(np.linalg.norm(bike.target-bike.position))*2./np.pi, bike.desiredVelocity - np.linalg.norm(bike.velocity)
    F = (bike.desiredVelocity - np.linalg.norm(bike.velocity)) * atan(np.linalg.norm(bike.target-bike.position))*2./np.pi * 0.02
    #print forceToDestination
    
#     forceToDestination = [0.1, 0.]
    F = 0.

    vxDot = differentialEquationInVx(bike.frontWheelCorneringStiffness, bike.frontWheelCorneringStiffness, 
                                    bike.frontWheelLength, bike.backWheelLength, 
                                    bike.getVelocityX(), bike.getVelocityY(), bike.inertialMomentum, 
                                    bike.mass, bike.frontWheelAngle, bike.psiDot, F)
    
#     vyDot = differentialEquationInVy(bike.frontWheelCorneringStiffness, bike.frontWheelCorneringStiffness, 
#                                     bike.frontWheelLength, bike.backWheelLength, 
#                                     bike.getVelocityX(), bike.getVelocityY(), bike.inertialMomentum, 
#                                     bike.mass, bike.frontWheelAngle, bike.psiDot, forceToDestination[1] * sin(bike.psi))

    vyDot = differentialEquationInVy(bike.frontWheelCorneringStiffness, bike.frontWheelCorneringStiffness, 
                                    bike.frontWheelLength, bike.backWheelLength, 
                                    bike.getVelocityX(), bike.getVelocityY(), bike.inertialMomentum, 
                                    bike.mass, bike.frontWheelAngle, bike.psiDot, 0.)
        
    psiDotDot = differentialEquationInInertialMomentum(bike.frontWheelCorneringStiffness, bike.backWheelCorneringStiffness, 
                                                      bike.frontWheelLength, bike.backWheelLength, 
                                                      bike.getVelocityX(), bike.getVelocityY(), bike.inertialMomentum, 
                                                      bike.frontWheelAngle, bike.psiDot)
    return vxDot, vyDot, psiDotDot

def updateVelocityAndYawDot(bike, vxDot, vyDot, timeStep):
    """ Updates the velocity in the inner frame y coordinate and the rate of orientation
    of the bicycle frame (psiDot) with respect to the outer XY frame
    Returns: vX, vY, psiDot 
    """
    vx     = bike.getVelocityX() + vxDot * timeStep
    vy     = bike.getVelocityY() + vyDot * timeStep
    psiDot = bike.psiDot + bike.psiDotDot * timeStep
    return vx, vy, psiDot

def rotateCoordinatesToTheExternalFrame(bike, timeStep):
    """ Computes the coordinates of the centre-of-mass in the external XY frame
    Returns: X, Y
    """ 
    psi = bike.psi + bike.psiDot * timeStep
    bike.updateYaw(psi)
        
    xDot = bike.getVelocityX() * cos(bike.psi) - bike.getVelocityY() * sin(bike.psi)
    yDot = bike.getVelocityX() * sin(bike.psi) + bike.getVelocityY() * cos(bike.psi)
        
    x = bike.getPositionX() + xDot * timeStep
    y = bike.getPositionY() + yDot * timeStep
    return x, y
    
def computeWheelPositions(bike):
    """ Computes and update the front and back wheel positions (centres of the wheels) and the position of the front
    and back of the front wheel
    Returns: none
    """
    frontWheelX = bike.getPositionX() + bike.frontWheelLength * cos(bike.psi)
    frontWheelY = bike.getPositionY() + bike.frontWheelLength * sin(bike.psi)
    bike.updateFrontWheelPosition(np.array([frontWheelX, frontWheelY]))
      
    backWheelX = bike.getPositionX() - bike.backWheelLength * cos(bike.psi)
    backWheelY = bike.getPositionY() - bike.backWheelLength * sin(bike.psi)
    bike.updateBackWheelPosition(np.array([backWheelX, backWheelY]))
        
    frontFrontWheelX = frontWheelX + bike.wheelRadius * cos(bike.psi + bike.frontWheelAngle)
    frontFrontWheelY = frontWheelY + bike.wheelRadius * sin(bike.psi + bike.frontWheelAngle)
    bike.updateFrontOfFrontWheelPosition(np.array([frontFrontWheelX, frontFrontWheelY]))
        
    backFrontWheelX = frontWheelX - bike.wheelRadius * cos(bike.psi + bike.frontWheelAngle)
    backFrontWheelY = frontWheelY - bike.wheelRadius * sin(bike.psi + bike.frontWheelAngle)
    bike.updateBackOfFrontWheelPosition(np.array([backFrontWheelX, backFrontWheelY]))
    
def dynamicalMatrix(Cf, Cr, lf, lr, Vx, Iz, m):
    '''Defines the 2x2 matrix for the dynamical system
    from [Vehicle Dynamics and Control Springer R. Rajamani]
    Returns: the 2x2 dynamical matrix
    '''
    topLeft     = (Cf + Cr) / (m * Vx)
    topRight    = - Vx - (Cf * lf - Cr * lr) / (m * Vx)
    bottomLeft  = - (lf * Cf - lr * Cr) / (Iz * Vx) 
    bottomRight = - (lf**2 * Cf + lr**2 * Cr) / (Iz * Vx) 
    return np.matrix([[topLeft, topRight], [bottomLeft, bottomRight]])

def nonHomogeneousMember(Cf, lf, delta, Iz, m):
    '''Defines the non-homogeneous member from the set of 
    differential equations, involving the front wheel steering angle
    Returns: non-homogeneous member
    '''
    return np.array([Cf/m, lf * Cf / Iz]) * delta

def bicycleDynamics(bike, bikes):
    """Solves and update for the bicycle dynamics by using the Lateral bicycle model
    Returns: none
    """
    # Solve the system of ODEs for vx, vy and psiDOt (lateral bicycle model)
    vxDot, vyDot, psiDotDot = systemOfODEsForDynamics(bike)
    bike.updateYawDotDot(psiDotDot)
    vx, vy, psiDot       = updateVelocityAndYawDot(bike, vxDot, vyDot, timeStep)
        
    # Update velocity and orientation
    if vx < 1.:
        vx = 1.
    bike.updateVelocity(np.array([vx, vy]))
    bike.updateYawDot(psiDot)
    
#     print 'velocity', sqrt(vx**2+vy**2)
        
    # Compute the coordinates of the centre-of-mass in the external frame
    x, y = rotateCoordinatesToTheExternalFrame(bike, timeStep)
        
    # Update
    bike.updatePosition(np.array([x, y]))
            
    # Compute some additional positions
    computeWheelPositions(bike)
    
    # Correct the steering angle towards the destination
    correctSteeringAngle(bike, bikes)
    
def addPlots(bike):
    """Adds bicycle to plot
    Returns: none
    """
    plt.plot(bike.getPositionX(), bike.getPositionY(), 'bo')
    plt.plot(bike.getTargetX(), bike.getTargetY(), 'ro')
    plt.plot([bike.getBackWheelX(), bike.getFrontWheelX()], [bike.getBackWheelY(), bike.getFrontWheelY()], 'b-', lw=2)
    plt.plot([bike.getFrontOfFrontWheelX(), bike.getBackOfFrontWheelX()], [bike.getFrontOfFrontWheelY(), bike.getBackOfFrontWheelY()], 'r-', lw=1)
        
def init():
       
    targetDots.set_data([], [])
    cdmDots.set_data([], [])
    frame1Dots.set_data([], [])
    frame2Dots.set_data([], [])
    frame3Dots.set_data([], [])
    wheel1Dots.set_data([], [])
    wheel2Dots.set_data([], [])
    wheel3Dots.set_data([], [])
    return cdmDots, frame1Dots, frame2Dots, frame3Dots, wheel1Dots, wheel2Dots, wheel3Dots
   
def animate(frames):
   
    t = time[frames]
    
    bicycleDynamics(bike1, [bike2, bike3])
    bicycleDynamics(bike2, [bike3, bike1])
    bicycleDynamics(bike3, [bike1, bike2])
        
    targetDots.set_data([bike1.getTargetX(), bike2.getTargetX(), bike3.getTargetX()], 
                        [bike1.getTargetY(), bike2.getTargetY(), bike3.getTargetY()])
    cdmDots.set_data([bike1.getPositionX(), bike2.getPositionX(), bike3.getPositionX()], 
                     [bike1.getPositionY(), bike2.getPositionY(), bike3.getPositionY()])
      
    backWheel1X = [bike1.getBackWheelX(), bike1.getFrontWheelX()]
    backWheel1Y = [bike1.getBackWheelY(), bike1.getFrontWheelY()]
    
    frame1Dots.set_data(backWheel1X, backWheel1Y)
    
    backWheel2X = [bike2.getBackWheelX(), bike2.getFrontWheelX()]
    backWheel2Y = [bike2.getBackWheelY(), bike2.getFrontWheelY()]
    
    frame2Dots.set_data(backWheel2X, backWheel2Y)
    
    backWheel3X = [bike3.getBackWheelX(), bike3.getFrontWheelX()]
    backWheel3Y = [bike3.getBackWheelY(), bike3.getFrontWheelY()]
    
    frame3Dots.set_data(backWheel3X, backWheel3Y)
      
    frontBackFrontWheel1X = [bike1.getFrontOfFrontWheelX(), bike1.getBackOfFrontWheelX()] 
    frontBackFrontWheel1Y = [bike1.getFrontOfFrontWheelY(), bike1.getBackOfFrontWheelY()] 

    wheel1Dots.set_data(frontBackFrontWheel1X, frontBackFrontWheel1Y)
    
    frontBackFrontWheel2X = [bike2.getFrontOfFrontWheelX(), bike2.getBackOfFrontWheelX()] 
    frontBackFrontWheel2Y = [bike2.getFrontOfFrontWheelY(), bike2.getBackOfFrontWheelY()] 

    wheel2Dots.set_data(frontBackFrontWheel2X, frontBackFrontWheel2Y)
    
    frontBackFrontWheel3X = [bike3.getFrontOfFrontWheelX(), bike3.getBackOfFrontWheelX()] 
    frontBackFrontWheel3Y = [bike3.getFrontOfFrontWheelY(), bike3.getBackOfFrontWheelY()] 

    wheel3Dots.set_data(frontBackFrontWheel3X, frontBackFrontWheel3Y)
    
    return cdmDots, frame1Dots, frame2Dots, frame3Dots, wheel1Dots, wheel2Dots, wheel3Dots

if __name__ == '__main__':
      
    plt.ion()
    
    #Initial instances
    bike1 = bicycle()
#    print bike1.preferred_controller("PID")
  
    bike2 = bicycle()
    bike3 = bicycle()
    #Initial positions
    bike1.updatePosition(np.array([-20., -20.]))
#     bike1.updateTarget(np.array([20., 20.]))
#     bike2.updatePosition(np.array([-10., -10.]))
#     bike2.updateTarget(np.array([10., 10.]))
#     bike3.updatePosition(np.array([-10., 0.]))
#     bike3.updateTarget(np.array([10., 0.]))


#     bike1.updatePosition(np.array([-10., -10.]))
#     bike1.updateTarget(np.array([2.5, 8.]))
#     bike2.updatePosition(np.array([10., -10.]))
#     bike2.updateTarget(np.array([-2.5, 8.]))
#     bike3.updatePosition(np.array([0., -2.]))
#     bike3.updateTarget(np.array([0., 8.]))
    timeStep = 0.5
    
    t = - timeStep
    
#     time = np.linspace(0., 1000., 2000)
#     figure       = plt.figure()
#     axes         = plt.axes(xlim=(-20, 20), ylim=(-20, 20)) 
#     targetDots,  = axes.plot([], [], 'ro')
#     cdmDots,     = axes.plot([], [], 'bo')
#     frame1Dots,  = axes.plot([], [], 'b-', lw=2)
#     frame2Dots,  = axes.plot([], [], 'b-', lw=2)
#     frame3Dots,  = axes.plot([], [], 'b-', lw=2)
#     wheel1Dots,  = axes.plot([], [], 'r-', lw=1)
#     wheel2Dots,  = axes.plot([], [], 'r-', lw=1)
#     wheel3Dots,  = axes.plot([], [], 'r-', lw=1)
#     anim=animation.FuncAnimation(figure, animate, init_func=init, frames=1000, interval=40, blit=True)
#     anim.save('lateral_bicycle_model_scaled2.mp4', bitrate=-1)
#     print 'video recorded.'
#     sys.exit()
         
    for i in range(1000):
        plt.cla()      
        plt.xlim([-30., 30.])
        plt.ylim([-30., 30.]) 
        
        t = t + timeStep
        
        bicycleDynamics(bike1, [bike2, bike3])
#         bicycleDynamics(bike2, [bike3, bike1])
#         bicycleDynamics(bike3, [bike1, bike2])
        
        addPlots(bike1)
        addPlots(bike2)
        addPlots(bike3)

        plt.show()
        plt.draw()
        plt.pause(0.001)
        